<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interval Timer with Tracking</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: background 0.5s ease;
            padding: 2rem;
        }

        body.interval {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        body.break {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .main-container {
            display: flex;
            gap: 2rem;
            max-width: 1200px;
            width: 100%;
            flex-wrap: wrap;
            justify-content: center;
        }

        .timer-container, .history-container {
            background: white;
            padding: 2rem;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .timer-container {
            text-align: center;
            flex: 0 1 400px;
        }

        .history-container {
            flex: 1 1 500px;
            min-width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }

        h1 {
            color: #333;
            margin-bottom: 2rem;
            font-size: 2rem;
        }

        h2 {
            color: #333;
            margin-bottom: 1.5rem;
            font-size: 1.5rem;
        }

        .status {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding: 0.5rem 1rem;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .status.interval {
            color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .status.break {
            color: #f5576c;
            background: rgba(245, 87, 108, 0.1);
        }

        .timer {
            font-size: 4rem;
            font-weight: 700;
            color: #333;
            margin: 2rem 0;
            font-variant-numeric: tabular-nums;
            letter-spacing: 0.05em;
        }

        .session-info {
            display: flex;
            justify-content: space-around;
            margin: 1.5rem 0;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 0.25rem;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 2rem 0;
            flex-wrap: wrap;
        }

        button {
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            min-width: 100px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        .start-btn {
            background: #667eea;
        }

        .pause-btn {
            background: #ffa500;
        }

        .stop-btn {
            background: #f5576c;
        }

        .reset-btn {
            background: #6c757d;
        }

        .export-btn {
            background: #28a745;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .settings {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid #eee;
        }

        .setting-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            color: #666;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
        }

        input[type="number"] {
            padding: 0.5rem;
            font-size: 1.2rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            width: 80px;
            text-align: center;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .unit {
            color: #666;
            font-size: 1rem;
        }

        .sound-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .history-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        .history-table th {
            background: #f8f9fa;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #dee2e6;
        }

        .history-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #dee2e6;
            color: #495057;
        }

        .history-table tr:hover {
            background: #f8f9fa;
        }

        .total-row {
            font-weight: 600;
            background: #e9ecef;
        }

        .total-row td {
            border-top: 2px solid #dee2e6;
        }

        .no-data {
            text-align: center;
            color: #6c757d;
            padding: 2rem;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .timer {
                font-size: 3rem;
            }
            
            .history-container {
                max-height: none;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body class="interval">
    <div class="main-container">
        <div class="timer-container">
            <h1>‚è±Ô∏è Interval Timer</h1>
            
            <div class="status interval" id="status">INTERVAL</div>
            
            <div class="timer" id="timer">00:00:00</div>
            
            <div class="session-info">
                <div class="info-item">
                    <div class="info-label">Current Interval</div>
                    <div class="info-value" id="currentInterval">1</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Total Time</div>
                    <div class="info-value" id="totalTime">00:00:00</div>
                </div>
            </div>
            
            <div class="controls">
                <button class="start-btn" id="startBtn" onclick="startTimer()">Start</button>
                <button class="pause-btn" id="pauseBtn" onclick="pauseTimer()" disabled>Stop</button>
                <button class="stop-btn" id="stopBtn" onclick="stopInterval()" disabled>End Interval</button>
                <button class="reset-btn" id="resetBtn" onclick="resetTimer()">Reset Session</button>
            </div>
            
            <div class="settings">
                <div class="setting-group">
                    <label for="breakDuration">Break Duration:</label>
                    <div class="input-group">
                        <input type="number" id="breakMinutes" min="0" max="59" value="0">
                        <span class="unit">min</span>
                        <input type="number" id="breakSeconds" min="0" max="59" value="20">
                        <span class="unit">sec</span>
                    </div>
                </div>
                
                <div class="sound-toggle">
                    <input type="checkbox" id="soundEnabled" checked>
                    <label for="soundEnabled">Sound notifications</label>
                </div>
            </div>
        </div>
        
        <div class="history-container">
            <h2>üìä Session History</h2>
            
            <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button class="export-btn" onclick="exportToExcel()" id="exportBtn">Export to Excel</button>
                <button class="save-btn" onclick="endAndSaveSession()" id="saveSessionBtn" style="background: #17a2b8;">End & Save Session</button>
                <button class="view-btn" onclick="togglePastSessions()" style="background: #20c997;">View Past Sessions</button>
                <button class="backup-btn" onclick="downloadBackup()" style="background: #6f42c1;">Download All Sessions</button>
                <label for="uploadBackup" class="backup-btn" style="background: #fd7e14; cursor: pointer; padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 600; border: none; border-radius: 10px; color: white; display: inline-block;">
                    Upload Backup
                    <input type="file" id="uploadBackup" accept=".json" onchange="uploadBackup(event)" style="display: none;">
                </label>
            </div>
            
            <div id="sessionInfo" style="margin-bottom: 1rem; padding: 0.75rem; background: #e9ecef; border-radius: 10px; font-size: 0.9rem; color: #495057;"></div>
            
            <div id="pastSessionsContainer" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 10px;">
                <h3 style="margin-bottom: 1rem;">üìÖ Past Sessions</h3>
                <div id="pastSessionsList"></div>
            </div>
            
            <div id="historyContent">
                <div class="no-data">No intervals recorded yet. Start your first interval!</div>
            </div>
        </div>
    </div>

    <script>
        let startTime = null;
        let elapsedTime = 0;
        let timerInterval = null;
        let currentMode = 'interval'; // 'interval' or 'break'
        let isRunning = false;
        let isPaused = false;
        let breakTimeRemaining = 0;
        let pausedBreakRemaining = 0;
        let currentIntervalNumber = 1;
        let totalSessionTime = 0;
        let intervalHistory = [];
        let sessionStartTime = null;
        
        // Session storage management
        let allSessions = loadSessions();
        
        // Load saved sessions from localStorage
        function loadSessions() {
            const saved = localStorage.getItem('intervalTimerSessions');
            return saved ? JSON.parse(saved) : [];
        }
        
        // Save sessions to localStorage
        function saveSessions(sessions) {
            localStorage.setItem('intervalTimerSessions', JSON.stringify(sessions));
            allSessions = sessions;
        }
        
        // Get last completed session
        function getLastSession() {
            return allSessions.length > 0 ? allSessions[allSessions.length - 1] : null;
        }

        // Audio context for beep sounds
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playBeep(frequency = 800, duration = 200) {
            if (!document.getElementById('soundEnabled').checked) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function formatTimeCompact(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }

        function formatDateTime(date) {
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            const day = date.getDate().toString().padStart(2, '0');
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            const seconds = date.getSeconds().toString().padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        function updateDisplay() {
            if (currentMode === 'interval') {
                const currentTime = Date.now();
                const totalElapsed = elapsedTime + (currentTime - startTime) / 1000;
                document.getElementById('timer').textContent = formatTime(totalElapsed);
                
                // Update total session time
                const sessionElapsed = totalSessionTime + totalElapsed;
                document.getElementById('totalTime').textContent = formatTime(sessionElapsed);
            } else {
                document.getElementById('timer').textContent = formatTime(breakTimeRemaining);
            }
        }

        function startTimer() {
            if (isRunning && !isPaused) return;
            
            // Check if we're resuming from pause
            if (isPaused) {
                isPaused = false;
                isRunning = true;
                
                if (currentMode === 'interval') {
                    // Resume interval timer
                    startTime = Date.now();
                    timerInterval = setInterval(updateDisplay, 100);
                } else {
                    // Resume break countdown
                    const breakStartTime = Date.now();
                    const remainingTime = pausedBreakRemaining;
                    
                    timerInterval = setInterval(() => {
                        const elapsed = (Date.now() - breakStartTime) / 1000;
                        breakTimeRemaining = Math.max(0, remainingTime - elapsed);
                        
                        updateDisplay();
                        
                        if (breakTimeRemaining === 0) {
                            clearInterval(timerInterval);
                            switchToInterval();
                        }
                    }, 100);
                }
                
                document.getElementById('startBtn').textContent = 'Start';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = currentMode === 'break';
                
                playBeep(600, 150);
                return;
            }
            
            // Starting fresh
            isRunning = true;
            startTime = Date.now();
            
            if (!sessionStartTime) {
                sessionStartTime = new Date();
            }
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('breakMinutes').disabled = true;
            document.getElementById('breakSeconds').disabled = true;
            
            timerInterval = setInterval(updateDisplay, 100);
            playBeep(600, 150);
        }

        function pauseTimer() {
            if (!isRunning || isPaused) return;
            
            clearInterval(timerInterval);
            isPaused = true;
            isRunning = false;
            
            // Save current state
            if (currentMode === 'interval') {
                // Save elapsed time
                elapsedTime += (Date.now() - startTime) / 1000;
            } else {
                // Save remaining break time
                pausedBreakRemaining = breakTimeRemaining;
            }
            
            // Update button states
            document.getElementById('startBtn').textContent = 'Resume';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            
            playBeep(500, 200);
        }

        function stopInterval() {
            if (!isRunning || currentMode !== 'interval') return;
            
            // Calculate interval duration
            const intervalDuration = elapsedTime + (Date.now() - startTime) / 1000;
            
            // Record interval
            const intervalEnd = new Date();
            const intervalStart = new Date(intervalEnd - intervalDuration * 1000);
            
            intervalHistory.push({
                intervalNumber: currentIntervalNumber,
                startTime: intervalStart,
                endTime: intervalEnd,
                duration: intervalDuration,
                formattedDuration: formatTime(intervalDuration),
                formattedDurationCompact: formatTimeCompact(intervalDuration)
            });
            
            // Update total session time
            totalSessionTime += intervalDuration;
            
            // Update history display
            updateHistoryDisplay();
            
            // Switch to break mode
            currentMode = 'break';
            document.getElementById('status').textContent = 'BREAK';
            document.getElementById('status').className = 'status break';
            document.body.className = 'break';
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            
            // Get break duration
            const breakMinutes = parseInt(document.getElementById('breakMinutes').value) || 0;
            const breakSeconds = parseInt(document.getElementById('breakSeconds').value) || 0;
            breakTimeRemaining = breakMinutes * 60 + breakSeconds;
            
            // Play notification
            playBeep(1000, 200);
            setTimeout(() => playBeep(1000, 200), 300);
            
            // Start break countdown
            const breakStartTime = Date.now();
            clearInterval(timerInterval);
            
            timerInterval = setInterval(() => {
                const elapsed = (Date.now() - breakStartTime) / 1000;
                breakTimeRemaining = Math.max(0, (breakMinutes * 60 + breakSeconds) - elapsed);
                
                updateDisplay();
                
                if (breakTimeRemaining === 0) {
                    // Break is over, switch back to interval
                    clearInterval(timerInterval);
                    switchToInterval();
                }
            }, 100);
        }

        function switchToInterval() {
            // Reset timer for new interval
            elapsedTime = 0;
            currentIntervalNumber++;
            
            currentMode = 'interval';
            document.getElementById('status').textContent = 'INTERVAL';
            document.getElementById('status').className = 'status interval';
            document.body.className = 'interval';
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('currentInterval').textContent = currentIntervalNumber;
            
            // Play notification
            playBeep(600, 200);
            setTimeout(() => playBeep(600, 200), 300);
            setTimeout(() => playBeep(600, 200), 600);
            
            // Start new interval timer
            startTime = Date.now();
            timerInterval = setInterval(updateDisplay, 100);
        }

        function resetTimer() {
            if (isRunning && !confirm('Are you sure you want to reset? This will clear all recorded intervals.')) {
                return;
            }
            
            clearInterval(timerInterval);
            
            startTime = null;
            elapsedTime = 0;
            breakTimeRemaining = 0;
            pausedBreakRemaining = 0;
            currentMode = 'interval';
            isRunning = false;
            isPaused = false;
            currentIntervalNumber = 1;
            totalSessionTime = 0;
            intervalHistory = [];
            sessionStartTime = null;
            
            document.getElementById('timer').textContent = '00:00:00';
            document.getElementById('totalTime').textContent = '00:00:00';
            document.getElementById('currentInterval').textContent = '1';
            document.getElementById('status').textContent = 'INTERVAL';
            document.getElementById('status').className = 'status interval';
            document.body.className = 'interval';
            
            document.getElementById('startBtn').textContent = 'Start';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('breakMinutes').disabled = false;
            document.getElementById('breakSeconds').disabled = false;
            
            updateHistoryDisplay();
            
            playBeep(400, 100);
        }

        function updateHistoryDisplay() {
            const historyContent = document.getElementById('historyContent');
            const lastSession = getLastSession();
            const sessionInfo = document.getElementById('sessionInfo');
            
            // Update session info
            if (lastSession) {
                const lastDate = new Date(lastSession.date);
                sessionInfo.innerHTML = `Last session: ${formatDateTime(lastDate)} - ${lastSession.totalIntervals} intervals, Total: ${formatTimeCompact(lastSession.totalTime)} | Total sessions saved: ${allSessions.length}`;
            } else {
                sessionInfo.innerHTML = 'No previous sessions saved yet.';
            }
            
            if (intervalHistory.length === 0) {
                historyContent.innerHTML = '<div class="no-data">No intervals recorded yet. Start your first interval!</div>';
                document.getElementById('exportBtn').disabled = true;
                document.getElementById('saveSessionBtn').disabled = true;
                return;
            }
            
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('saveSessionBtn').disabled = false;
            
            let html = '<table class="history-table">';
            html += '<thead><tr>';
            html += '<th>Interval #</th>';
            html += '<th>Current Session</th>';
            if (lastSession && lastSession.intervals) {
                html += '<th>Last Session</th>';
                html += '<th>Difference</th>';
            }
            html += '</tr></thead>';
            html += '<tbody>';
            
            intervalHistory.forEach((interval, index) => {
                html += '<tr>';
                html += `<td>${interval.intervalNumber}</td>`;
                html += `<td>${interval.formattedDurationCompact || formatTimeCompact(interval.duration)}</td>`;
                
                if (lastSession && lastSession.intervals && lastSession.intervals[index]) {
                    const prevDuration = lastSession.intervals[index].duration;
                    const diff = interval.duration - prevDuration;
                    const diffFormatted = formatTimeCompact(Math.abs(diff));
                    const sign = diff >= 0 ? '+' : '-';
                    // Green if longer (better), red if shorter (worse)
                    const color = diff >= 0 ? '#28a745' : '#dc3545';
                    
                    html += `<td>${formatTimeCompact(prevDuration)}</td>`;
                    html += `<td style="color: ${color}; font-weight: 600;">${sign}${diffFormatted}</td>`;
                } else if (lastSession) {
                    html += '<td>-</td>';
                    html += '<td>-</td>';
                }
                
                html += '</tr>';
            });
            
            // Add summary row
            html += '<tr class="total-row">';
            html += `<td>Total (${intervalHistory.length})</td>`;
            html += `<td>${formatTimeCompact(totalSessionTime)}</td>`;
            if (lastSession && lastSession.intervals) {
                html += `<td>${formatTimeCompact(lastSession.totalTime)}</td>`;
                const totalDiff = totalSessionTime - lastSession.totalTime;
                const sign = totalDiff >= 0 ? '+' : '-';
                // Green if longer total (better), red if shorter (worse)
                const color = totalDiff >= 0 ? '#28a745' : '#dc3545';
                html += `<td style="color: ${color}; font-weight: 600;">${sign}${formatTimeCompact(Math.abs(totalDiff))}</td>`;
            }
            html += '</tr>';
            
            html += '</tbody></table>';
            
            historyContent.innerHTML = html;
        }

        function togglePastSessions() {
            const container = document.getElementById('pastSessionsContainer');
            if (container.style.display === 'none') {
                container.style.display = 'block';
                displayPastSessions();
            } else {
                container.style.display = 'none';
            }
        }
        
        function displayPastSessions() {
            const pastSessionsList = document.getElementById('pastSessionsList');
            
            if (allSessions.length === 0) {
                pastSessionsList.innerHTML = '<p>No past sessions saved yet.</p>';
                return;
            }
            
            let html = '<div style="max-height: 400px; overflow-y: auto;">';
            
            // Display sessions in reverse order (newest first)
            for (let i = allSessions.length - 1; i >= 0; i--) {
                const session = allSessions[i];
                const sessionDate = new Date(session.date);
                const isLatest = i === allSessions.length - 1;
                
                html += `<div style="margin-bottom: 1.5rem; padding: 1rem; background: white; border-radius: 8px; border: 1px solid #dee2e6;">`;
                html += `<div style="font-weight: 600; margin-bottom: 0.5rem; color: ${isLatest ? '#17a2b8' : '#495057'};">`;
                html += `Session ${i + 1} - ${formatDateTime(sessionDate)}`;
                if (isLatest) html += ' (Latest)';
                html += `</div>`;
                
                html += `<div style="display: flex; gap: 1rem; margin-bottom: 0.5rem; font-size: 0.9rem;">`;
                html += `<span>Intervals: <strong>${session.totalIntervals}</strong></span>`;
                html += `<span>Total: <strong>${formatTimeCompact(session.totalTime)}</strong></span>`;
                if (session.breakDuration) {
                    const breakTotal = session.breakDuration.minutes * 60 + session.breakDuration.seconds;
                    html += `<span>Break: <strong>${formatTimeCompact(breakTotal)}</strong></span>`;
                }
                html += `</div>`;
                
                // Show interval details
                if (session.intervals && session.intervals.length > 0) {
                    html += '<table style="width: 100%; margin-top: 0.5rem; font-size: 0.9rem;">';
                    html += '<tr style="border-bottom: 1px solid #dee2e6;">';
                    html += '<th style="padding: 0.25rem; text-align: left;">Int #</th>';
                    html += '<th style="padding: 0.25rem; text-align: left;">Duration</th>';
                    if (i > 0 && allSessions[i-1].intervals) {
                        html += '<th style="padding: 0.25rem; text-align: left;">vs Previous</th>';
                    }
                    html += '</tr>';
                    
                    session.intervals.forEach((interval, idx) => {
                        html += '<tr>';
                        html += `<td style="padding: 0.25rem;">${idx + 1}</td>`;
                        html += `<td style="padding: 0.25rem;">${interval.formattedDurationCompact || formatTimeCompact(interval.duration)}</td>`;
                        
                        // Compare with previous session
                        if (i > 0 && allSessions[i-1].intervals && allSessions[i-1].intervals[idx]) {
                            const prevDuration = allSessions[i-1].intervals[idx].duration;
                            const diff = interval.duration - prevDuration;
                            const color = diff >= 0 ? '#28a745' : '#dc3545';
                            const sign = diff >= 0 ? '+' : '-';
                            html += `<td style="padding: 0.25rem; color: ${color}; font-weight: 600;">${sign}${formatTimeCompact(Math.abs(diff))}</td>`;
                        } else if (i > 0) {
                            html += '<td style="padding: 0.25rem;">-</td>';
                        }
                        
                        html += '</tr>';
                    });
                    html += '</table>';
                }
                
                html += `</div>`;
            }
            
            html += '</div>';
            pastSessionsList.innerHTML = html;
        }
        
        function endAndSaveSession() {
            if (intervalHistory.length === 0) {
                alert('No intervals to save! Complete at least one interval before saving the session.');
                return;
            }
            
            const confirmSave = confirm(`Save current session with ${intervalHistory.length} intervals?\n\nThis will save the session and reset the timer for a new session.`);
            if (!confirmSave) return;
            
            // Ensure all intervals have compact format
            intervalHistory.forEach(interval => {
                if (!interval.formattedDurationCompact) {
                    interval.formattedDurationCompact = formatTimeCompact(interval.duration);
                }
            });
            
            // Create session data
            const sessionData = {
                date: sessionStartTime || new Date(),
                intervals: intervalHistory.map(i => ({...i})), // Deep copy
                totalTime: totalSessionTime,
                totalIntervals: intervalHistory.length,
                breakDuration: {
                    minutes: parseInt(document.getElementById('breakMinutes').value) || 0,
                    seconds: parseInt(document.getElementById('breakSeconds').value) || 0
                }
            };
            
            // Add to all sessions
            allSessions.push(sessionData);
            saveSessions(allSessions);
            
            alert(`Session saved successfully!\n${intervalHistory.length} intervals recorded\nTotal time: ${formatTimeCompact(totalSessionTime)}`);
            
            // Reset for new session
            resetTimer();
        }
        
        function downloadBackup() {
            if (allSessions.length === 0) {
                alert('No sessions to backup! Complete and save at least one session first.');
                return;
            }
            
            const backupData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                totalSessions: allSessions.length,
                sessions: allSessions
            };
            
            const dataStr = JSON.stringify(backupData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            const dateStr = new Date().toISOString().split('T')[0];
            link.download = `interval_timer_all_sessions_${dateStr}.json`;
            link.click();
            
            playBeep(800, 100);
            setTimeout(() => playBeep(1000, 100), 150);
            
            alert(`Backup downloaded!\n${allSessions.length} sessions exported.`);
        }
        
        function uploadBackup(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const backupData = JSON.parse(e.target.result);
                    
                    // Handle both old format (direct array) and new format (with metadata)
                    let sessions;
                    if (Array.isArray(backupData)) {
                        sessions = backupData;
                    } else if (backupData.sessions && Array.isArray(backupData.sessions)) {
                        sessions = backupData.sessions;
                    } else {
                        throw new Error('Invalid backup format');
                    }
                    
                    const confirmUpload = confirm(`This backup contains ${sessions.length} sessions.\n\nDo you want to:\n- OK: Replace current data (${allSessions.length} sessions)\n- Cancel: Merge with current data`);
                    
                    if (confirmUpload) {
                        // Replace all sessions
                        saveSessions(sessions);
                        alert(`Backup restored successfully!\n${sessions.length} sessions loaded.`);
                    } else {
                        // Merge sessions (add new ones)
                        const merged = [...allSessions, ...sessions];
                        // Remove duplicates based on date
                        const unique = merged.filter((session, index, self) => 
                            index === self.findIndex(s => 
                                new Date(s.date).getTime() === new Date(session.date).getTime()
                            )
                        );
                        saveSessions(unique);
                        alert(`Sessions merged!\nTotal sessions: ${unique.length}`);
                    }
                    
                    // Reload the page to refresh display
                    location.reload();
                    
                } catch (err) {
                    alert('Error reading backup file: ' + err.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }

        function exportToExcel() {
            if (intervalHistory.length === 0) {
                alert('No data to export!');
                return;
            }
            
            // Prepare data for Excel
            const worksheetData = [
                ['Interval Timer Session Report'],
                ['Session Date:', formatDateTime(sessionStartTime || new Date())],
                ['Total Intervals:', intervalHistory.length],
                ['Total Session Time:', formatTime(totalSessionTime)],
                [],
                ['Interval #', 'Start Time', 'End Time', 'Duration (HH:MM:SS)', 'Duration (seconds)']
            ];
            
            intervalHistory.forEach(interval => {
                worksheetData.push([
                    interval.intervalNumber,
                    formatDateTime(interval.startTime),
                    formatDateTime(interval.endTime),
                    interval.formattedDuration,
                    Math.round(interval.duration)
                ]);
            });
            
            // Add summary row
            worksheetData.push([]);
            worksheetData.push(['TOTAL', '', '', formatTime(totalSessionTime), Math.round(totalSessionTime)]);
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(worksheetData);
            
            // Set column widths
            ws['!cols'] = [
                { wch: 12 },  // Interval #
                { wch: 20 },  // Start Time
                { wch: 20 },  // End Time
                { wch: 18 },  // Duration (formatted)
                { wch: 18 }   // Duration (seconds)
            ];
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, 'Interval Session');
            
            // Generate filename with current date
            const now = new Date();
            const filename = `interval_timer_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}${now.getMinutes().toString().padStart(2,'0')}.xlsx`;
            
            // Save file
            XLSX.writeFile(wb, filename);
            
            playBeep(800, 100);
            setTimeout(() => playBeep(1000, 100), 150);
        }

        // Initialize display
        updateHistoryDisplay();

        // Prevent accidental page refresh and auto-save reminder
        window.addEventListener('beforeunload', (e) => {
            if (intervalHistory.length > 0) {
                // Note: Modern browsers don't show custom messages, just a generic warning
                e.preventDefault();
                e.returnValue = 'You have unsaved intervals. Are you sure you want to leave?';
            }
        });
    </script>
</body>
</html>